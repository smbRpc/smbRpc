module SmbRpc
  class Svcctl < Rpc

#[MS-SCMR] Specific access types for Service Control Manager object
SC_ACCESS_MASK = {
  "SC_MANAGER_LOCK" => 0x00000008,		#Required to lock the SCM database.
  "SC_MANAGER_CREATE_SERVICE" => 0x00000002,	#Required for a service to be created
  "SC_MANAGER_ENUMERATE_SERVICE" => 0x00000004,	#Required to enumerate a service
  "SC_MANAGER_CONNECT" => 0x00000001,		#Required to connect to the SCM
  "SC_MANAGER_QUERY_LOCK_STATUS" => 0x00000010,	#Required to query the lock status of the SCM database
  "SC_MANAGER_MODIFY_BOOT_CONFIG" => 0x0020,	#Required to call the RNotifyBootConfigStatus method
#https://docs.microsoft.com/en-us/windows/desktop/Services/service-security-and-access-rights
  "SC_MANAGER_ALL_ACCESS" => 0xF003F
}

#[MS-SCMR]
SERVICE_ACCESS_MASK = {
  "SERVICE_ALL_ACCESS" => 0x000F01FF,
  "SERVICE_CHANGE_CONFIG" => 0x00000002,
  "SERVICE_ENUMERATE_DEPENDENTS" => 0x00000008,
  "SERVICE_INTERROGATE" => 0x00000080,
  "SERVICE_PAUSE_CONTINUE" => 0x00000040,
  "SERVICE_QUERY_CONFIG" => 0x00000001,
  "SERVICE_QUERY_STATUS" => 0x00000004,
  "SERVICE_START" => 0x00000010,
  "SERVICE_STOP" => 0x00000020,
  "SERVICE_USER_DEFINED_CONTROL" => 0x00000100,
  "SERVICE_SET_STATUS" => 0x00008000
}
#[MS-SCMR] This MUST be one or a combination of the following values
SERVICE_TYPE = {
  "SERVICE_KERNEL_DRIVER" => 0x00000001,
  "SERVICE_FILE_SYSTEM_DRIVER" => 0x00000002,
  "SERVICE_WIN32_OWN_PROCESS" => 0x00000010,
  "SERVICE_WIN32_SHARE_PROCESS" => 0x00000020,
  "ALL" => 0x33
}
#[MS-SCMR] This MUST be one of the following values
SERVICE_STATE = {
  "SERVICE_ACTIVE" => 0x01,	#get ServiceStatus.dwCurrentState = SERVICE_START_PENDING, SERVICE_STOP_PENDING, SERVICE_RUNNING, SERVICE_CONTINUE_PENDING, SERVICE_PAUSE_PENDING, and SERVICE_PAUSED
  "SERVICE_INACTIVE" => 0x02,	#SERVICE_STOPPED
  "SERVICE_STATE_ALL" => 0x03	#SERVICE_START_PENDING, SERVICE_STOP_PENDING, SERVICE_RUNNING, SERVICE_CONTINUE_PENDING, SERVICE_PAUSE_PENDING, SERVICE_PAUSED, and SERVICE_STOPPED
}

#[MS-SCMR] Only SERVICE_WIN32_OWN_PROCESS and SERVICE_INTERACTIVE_PROCESS OR SERVICE_WIN32_SHARE_PROCESS and SERVICE_INTERACTIVE_PROCESS can be combined
SERVICE_STATUS_SERVICE_TYPE = {
  "SERVICE_KERNEL_DRIVER" => 0x00000001,
  "SERVICE_FILE_SYSTEM_DRIVER" => 0x00000002,
  "SERVICE_WIN32_OWN_PROCESS" => 0x00000010,
  "SERVICE_WIN32_SHARE_PROCESS" => 0x00000020,
  "SERVICE_INTERACTIVE_PROCESS" => 0x00000100,
  "SERVICE_WIN32_OWN_PROCESS | SERVICE_INTERACTIVE_PROCESS" => 0x00000110,
  "SERVICE_WIN32_SHARE_PROCESS | SERVICE_INTERACTIVE_PROCESS" => 0x00000120
}

SERVICE_STATUS_CURRENT_STATE = {
  0x00000005 => "SERVICE_CONTINUE_PENDING",
  0x00000006 => "SERVICE_PAUSE_PENDING",
  0x00000007 => "SERVICE_PAUSED",
  0x00000004 => "SERVICE_RUNNING",
  0x00000002 => "SERVICE_START_PENDING",
  0x00000003 => "SERVICE_STOP_PENDING",
  0x00000001 => "SERVICE_STOPPED"
}
SERVICE_START_TYPE = {
  "SERVICE_BOOT_START" => 0x00000000,
  "SERVICE_SYSTEM_START" => 0x00000001,
  "SERVICE_AUTO_START" => 0x00000002,
  "SERVICE_DEMAND_START" => 0x00000003,
  "SERVICE_DISABLED" => 0x00000004
}

SERVICE_ERROR_CONTROL = {
  "SERVICE_ERROR_IGNORE" => 0x00000000,
  "SERVICE_ERROR_NORMAL" => 0x00000001,
  "SERVICE_ERROR_SEVERE" => 0x00000002,
  "SERVICE_ERROR_CRITICAL" => 0x00000003
}

SERVICE_CONTROL = {
  "SERVICE_CONTROL_CONTINUE" => 0x00000003,
  "SERVICE_CONTROL_INTERROGATE" => 0x00000004,
  "SERVICE_CONTROL_NETBINDADD" => 0x00000007,
  "SERVICE_CONTROL_NETBINDDISABLE" => 0x0000000A,
  "SERVICE_CONTROL_NETBINDENABLE" => 0x00000009,
  "SERVICE_CONTROL_NETBINDREMOVE" => 0x00000008,
  "SERVICE_CONTROL_PARAMCHANGE" => 0x00000006,
  "SERVICE_CONTROL_PAUSE" => 0x00000002,
  "SERVICE_CONTROL_STOP" => 0x00000001,
}

    class OpenScmReq < BinData::Record
      endian :little
      request :request
      uint32 :ref_id_machine_name, :value => 1 
      conformantandVaryingStrings :machine_name
      uint32 :databaseName
      uint32 :desiredAccess

      def initialize_instance
        super
        machine_name.str = "\\\\#{get_parameter(:serverName)}\x00".bytes.pack("v*")
        desiredAccess.value = get_parameter(:accessMask)
        request.pduHead.frag_length = self.num_bytes
        request.opnum.value = 15	#ROpenSCManagerW
      end
    end

    class OpenScmRes < BinData::Record
      endian :little
      response :response
      string :scHandle, :length => 20
      uint32 :windowsError
    end

    class EnumServicesStatusReq < BinData::Record
      default_parameter :bytesNeeded => 0
      endian :little
      request :request
      string :scHandle, :length => 20
      uint32 :serviceType
      uint32 :serviceState
      uint32 :bufSize
      uint32 :ref_id_resume, :value => 1
      uint32 :resume_handle

      def initialize_instance
        super
        scHandle.value = get_parameter(:handle)
        bufSize.value = get_parameter(:bytesNeeded)
        serviceType.value = get_parameter(:type)
        serviceState.value = get_parameter(:state)
        request.pduHead.frag_length = self.num_bytes
        request.opnum.value = 14	#REnumServicesStatusW
      end
    end

    class Service_status < BinData::Record
      endian :little
      uint32 :ref_id_serviceName
      uint32 :ref_id_displayName
      uint32 :serviceType		#SERVICE_STATUS nested struct begin
      uint32 :currentState		#different from SmbRpc::Svcctl::SERVICE_STATE
      uint32 :controlsAccepted
      uint32 :win32ExitCode
      uint32 :serviceSpecificExitCode
      uint32 :checkPoint
      uint32 :waitHint			#SERVICE_STATUS nested struct ends
      string :serviceName
      string :displayName
    end

    class Enum_service_statusw < BinData::Record
      array :service_status_array, :type => :service_status, :initial_length => :servicesReturned
      #array :serviceName, :type => :string, :initial_length => :servicesReturned
      #array :serviceDescription, :type => :string, :initial_length => :servicesReturned
    end

    class EnumServicesStatusRes < BinData::Record
      endian :little
      request :response
      uint32 :buffLen
      string :buffer, :onlyif => lambda{ buffLen > 0 }, :read_length => :buffLen
      uint32 :bytesNeeded
      uint32 :servicesReturned
      uint32 :ref_id_resumeIndex
      uint32 :resumeIndex
      uint32 :windowsError

      def getService
        enum_service_statusw = Enum_service_statusw.new(:servicesReturned => self.servicesReturned)
        enum_service_statusw.read(self.buffer)
        num = self.servicesReturned * 36
#        serviceStr = self.buffer[num..-1 ].scan(/.+?\x00\x00\x00/)
        serviceStr = self.buffer[num..-1 ].scan(/\w.+?\x00\x00\x00/)
        len = enum_service_statusw.service_status_array.length - 1	#get service array index
        len.downto(0).each do |idx|	#lopp backward b/c MS thaough it was cool to add a buffer in the middle of struct :(
          enum_service_statusw.service_status_array[idx].displayName = serviceStr.pop.unpack("v*").pack("C*").chop
          enum_service_statusw.service_status_array[idx].serviceName = serviceStr.pop.unpack("v*").pack("C*").chop
        end
        return enum_service_statusw.service_status_array
      end
    end

    class OpenServiceReq < BinData::Record
      endian :little
      request :request
      string :scHandle, :length => 20
      conformantandVaryingStrings :serviceName
      uint32 :desiredAccess

      def initialize_instance
        super
        scHandle.value = get_parameter(:handle)
        serviceName.str = "#{get_parameter(:svcName)}\x00".bytes.pack("v*")
        desiredAccess.value = get_parameter(:access)
        request.pduHead.frag_length = self.num_bytes
        request.opnum.value = 16        #ROpenServiceW
      end
    end

    class OpenServiceRes < BinData::Record
      endian :little
      request :request
      string :serviceHandle, :length => 20
      uint32 :windowsError
    end

    class CloseServiceHandleReq < BinData::Record			#use to close BOTH SC and service handle
      endian :little
      request :request
      string :serviceHandle, :length => 20

      def initialize_instance
        super
        serviceHandle.value = get_parameter(:handle)
        request.pduHead.frag_length = self.num_bytes
        request.opnum.value = 0        #RCloseServiceHandle
      end
    end

    class CloseServiceHandleRes < BinData::Record
      endian :little
      request :request
      string :serviceHandle, :length => 20
      uint32 :windowsError
    end

    class QueryServiceConfigReq  < BinData::Record
      mandatory_parameter :handle
      endian :little
      request :request
      string :serviceHandle, :length => 20
      uint32 :bufSize

      def initialize_instance
        super
        serviceHandle.value = get_parameter(:handle)
        bufSize.value = get_parameter(:bytesNeeded)
        request.pduHead.frag_length = self.num_bytes
        request.opnum.value = 17	#RQueryServiceConfigW
      end
    end

    class Query_service_configw  < BinData::Record
      endian :little
      uint32 :serviceType
      uint32 :startType
      uint32 :errorControl
      uint32 :ref_id_binaryPathName
      uint32 :ref_id_loadOrderGroup
      uint32 :tagId
      uint32 :ref_id_dependencies
      uint32 :ref_id_serviceStartName
      uint32 :ref_id_displayName
      conformantandVaryingStrings :binaryPathName
      conformantandVaryingStrings :loadOrderGroup
      conformantandVaryingStrings :dependencies
      conformantandVaryingStrings :serviceStartName
      conformantandVaryingStrings :displayName
    end

    class QueryServiceConfigRes < BinData::Record
      endian :little
      request :response
      query_service_configw :serviceConfig
      uint32 :bytesNeeded	#bytes needed to return all data if function fail
      uint32 :windowsError
    end

    class CreateServiceReq < BinData::Record
      endian :little
      request :request
      string :scHandle, :length => 20
      conformantandVaryingStrings :serviceName #top level reference pointer, so no need ref_id
      #top level unique pointer, so need ref_id.  combination of onlyif and choice to create null or not null pointer
      uint32 :ref_id_displayName, :value => 1, :onlyif => lambda { displayLen > 0 }	#if not a null pointer
      choice :displayName, :selection => lambda { displayLen } do
        conformantandVaryingStrings :default						#if not a null pointer
        uint32 0									#if null pointer
      end
      uint32 :desiredAccess
      uint32 :serviceType
      uint32 :startType
      uint32 :errorControl
      conformantandVaryingStrings :binaryPathName
      uint32 :loadOrderGroup			#might implement this, tagId, and dependencies later
      uint32 :tagId
      uint32 :dependencies
      uint32 :dependSize
      uint32 :serviceStartName			#not going to implement this cause ncacn_np may require password encryption
      uint32 :password				#and default service account is LocalSystem anyway	
      uint32 :pwSize

      def initialize_instance
        super
        scHandle.value = get_parameter(:handle)
        serviceName.str = "#{get_parameter(:name)}\x00".bytes.pack("v*")
        displayName.str = "#{get_parameter(:display)}\x00".bytes.pack("v*") if displayLen > 0 #if display not empty
        binaryPathName.str = "#{get_parameter(:path)}\x00".bytes.pack("v*")
        desiredAccess.value = get_parameter(:access)
        serviceType.value = get_parameter(:type)
        startType.value = get_parameter(:start)
        errorControl.value = get_parameter(:error)
        request.pduHead.frag_length = self.num_bytes
        request.opnum.value = 12        #RCreateServiceW
      end

      def displayLen	#helper method to get displayname length
        get_parameter(:display).bytesize
      end
    end

    class CreateServiceRes < BinData::Record
      endian :little
      request :response
      uint32 :tagId
      string :serviceHandle, :length => 20
      uint32 :windowsError
    end

    class DeleteServiceReq < BinData::Record
      endian :little
      request :request
      string :serviceHandle, :length => 20

      def initialize_instance
        super
        serviceHandle.value = get_parameter(:handle)
        request.pduHead.frag_length = self.num_bytes
        request.opnum.value = 2        #RDeleteService
      end
    end

    class DeleteServiceRes < BinData::Record
      endian :little
      request :response
      uint32 :windowsError
    end

    class StartServiceReq  < BinData::Record	#what happen to consistency MS? 
      mandatory_parameter :handle
      endian :little
      request :request
      string :serviceHandle, :length => 20
      uint32 :argc
      uint32 :argv

      def initialize_instance
        super
        serviceHandle.value = get_parameter(:handle)
        request.pduHead.frag_length = self.num_bytes
        request.opnum.value = 19        #RStartServiceW
      end
    end

    class StartServiceRes  < BinData::Record
      endian :little
      request :response
      uint32 :windowsError
    end

    class ControlServiceReq  < BinData::Record	#probably same question others have asked before, why missing only START service?
      endian :little
      request :request
      string :serviceHandle, :length => 20
      uint32 :control

      def initialize_instance
        super
        serviceHandle.value = get_parameter(:handle)
        control.value = get_parameter(:serviceControl)
        request.pduHead.frag_length = self.num_bytes
        request.opnum.value = 1        #RControlService
      end
    end

    class ControlServiceRes  < BinData::Record
      endian :little
      request :response
      uint32 :serviceType
      uint32 :currentState
      uint32 :controlsAccepted
      uint32 :win32ExitCode
      uint32 :serviceSpecificExitCode
      uint32 :checkPoint
      uint32 :waitHint
      uint32 :windowsError
    end

#end to cap module-class
  end
end
