
module SmbRpc
  class Rpc
    def initialize(ip:, port:445, user:"", pass:"")
      @ip = ip
      @port = port
      @user = user
      @pass = pass
    end

    def connect
      sock = TCPSocket.open(@ip, @port)
      dispatcher = RubySMB::Dispatcher::Socket.new(sock)
      @smb = RubySMB::Client.new(dispatcher, smb1: true, smb2: true, username: @user, password: @pass)
      result = @smb.login.value 
      result == 0? result : (raise "Connect Fail, WinError: %i"%[result])
    end

#    def bind(pipe:, uuid:PIPE[pipe][0], version:PIPE[pipe][1])
    def bind(pipe:)
      @ipc = @smb.tree_connect("\\\\#{@ip}\\IPC$")
      @file = @ipc.open_file(filename: pipe, read: true, write: true)
      @file.bind(endpoint: ENDPOINT[pipe])	#ruby_smb bind uses modules as endpoints, so setup and give it one
#      bind = Bind.new(uuid: uuid,ver: version)	#otherwise do it manually like this, too much work
#      @file.write(data: bind.to_binary_s)
#      bind_ack = Bind_ack.read(@file.read(bytes: 0xffff))
#      result = bind_ack.p_result_list.p_result.result
#      reason = bind_ack.p_result_list.p_result.reason
#      #assocGroupId =  bindAck.assoc_group_id
#      result == 0? result : (raise "Bind Fail: %s %s"%[P_CONT_DEF_RESULT_T.key(result), P_PROVIDER_REASON_T.key(reason)])
    end

    def close
      @file.close if @file != nil
      @smb.disconnect!
    end
  end
end
