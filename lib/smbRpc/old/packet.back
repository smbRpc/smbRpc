#!/usr/bin/ruby
require"bindata"

PFC_FIRST_FRAG = 0x01
PFC_LAST_FRAG = 0x02
PFC_PENDING_CANCEL = 0x04
PFC_RESERVED_1 = 0x08
PFC_CONC_MPX = 0x10
PFC_DID_NOT_EXECUTE = 0x20
PFC_MAYBE = 0x40
PFC_OBJECT_UUID = 0x80

class P_syntax_id_t < BinData::Record
  endian :little
  string :if_uuid, :length => 16
  uint16 :if_version_major
  uint16 :if_version_minor

  def ndrParse(uuidStr, ver)
    uuidArr = uuidStr.split("-")
    uuidArr[0] = uuidArr[0].to_i(16)
    uuidArr[1] = uuidArr[1].to_i(16)
    uuidArr[2] = uuidArr[2].to_i(16)
    uuidArr[3] = uuidArr[3].to_i(16)
    if_uuid.value = uuidArr.pack("VvvnH*")
    verArr = ver.to_s.split(".")
    if_version_major.value = verArr[0].to_i
    if_version_minor.value = verArr[1].to_i
  end
end

class PduHead < BinData::Record
  endian :little
  uint8  :rpc_vers, :initial_value => 5
  uint8  :rpc_vers_minor
  uint8  :ptype					#packet type
  uint8  :pfc_flags, :initial_value => lambda{ PFC_FIRST_FRAG | PFC_LAST_FRAG }			#flags (see PFC_... )
  uint32 :drep, :initial_value => 0x10		#NDR data representation format label
  uint16 :frag_length				#total length of the PDU
  uint16 :auth_length				#length of auth_value
  uint32 :call_id, :initial_value => 1		#call identifier for matching rewponse like smb msg ID
end

#12.6.4.3 The bind PDU
class Bind < BinData::Record
mandatory_parameter :uuid, :ver

  endian :little
  pduHead :pduHead
  uint16 :max_xmit_frag, :initial_value => 0xffff	#max transnit pdu size
  uint16 :max_recv_frag, :initial_value => 0xffff	#max receive pdu size
  uint32 :assoc_group_id				#client set to 0 indicate a new session, 
							#server returns a new one in rpc_bind_ack 

#pContentList :p_cont_elem				#list of available presentation(OSI model) syntax(abstract/transfer)
  uint8  :n_context_elem, :initial_value => 1
  uint8 :reserved
  uint16 :reserved2

#PContentElement
  uint16 :p_context_id
  uint8 :n_transfer_syn, :initial_value => 1
  uint8 :reserved3
  p_syntax_id_t :abstract_syntax
  p_syntax_id_t :transfer_syntax

  def initialize_instance
    super
    pduHead.frag_length = self.num_bytes
    pduHead.ptype = 0x0b
    abstract_syntax.ndrParse(get_parameter(:uuid),get_parameter(:ver))		#set srvsvc uuid and version
    transfer_syntax.ndrParse("8a885d04-1ceb-11c9-9fe8-08002b104860", 2.0)	#set default NDR transfer syntax and version
  end
end

class Port_any_t < BinData::Record
  endian :little
  uint16 :len
  string :port_spec, :length => :len
end

class P_result_t < BinData::Record
  endian :little
  uint16 :result
  uint16 :reason
  p_syntax_id_t :transfer_syntax
end

class P_result_list_t < BinData::Record
  endian :little
  uint8 :n_results
  uint8 :reserved
  uint16 :reserved2
  p_result_t :p_result
end


class Bind_ack < BinData::Record
  endian :little
  pduHead :pduHead
  uint16 :max_xmit_frag					#max transnit pdu size
  uint16 :max_recv_frag					#max receive pdu size
  uint32 :assoc_group_id                                #new assotiation group rfom server 
  port_any_t :sec_addr
  string :pad2, :length => lambda {4 - (pad2.abs_offset % 4)}	#pad 4 bytes aligned from begin to sec_addr
  p_result_list_t :p_result_list
  string :auth_verifier, :onlyif => lambda { pduHead.auth_length > 0 }, :length => lambda { pduHead.auth_length }
end

class Request < BinData::Record
  endian :little
  pduHead :pduHead
  uint32 :alloc_hint
  uint16 :p_cont_id
  uint16 :opnum
  #string :object, :length => 16, :onlyif => lambda { pduHead.pfc_flags & PFC_OBJECT_UUID }
  #string :auth_verifier, :onlyif => lambda { pduHead.auth_length > 0 }, :length => lambda { pduHead.auth_length }

end


class ConformantandVaryingStrings < BinData::Record
  endian :little
  uint32 :max_count, :value => lambda{ str.num_bytes / 2}
  uint32 :offset
  uint32 :actual_count, :value => :max_count
  string :str, :read_length => lambda { if max_count.nonzero?; return max_count.value * 2; end} 
  string :pad, :onlyif => lambda{ (str.num_bytes % 4) > 0}, :length => lambda { (4 - (str.num_bytes % 4)) % 4 }
end

class Share_info_0 < BinData::Record
  endian :little
  uint32 :ref_id_shi0_netname, :initial_value => 1
  uint32 :max_count
  array :ref_id_array, :type => :uint32, :initial_length => :max_count
  array :conformantandVaryingStringsArray, :type => :conformantandVaryingStrings, :initial_length => :max_count
end


class Share_info_0_container < BinData::Record
  endian :little
  uint32 :entriesRead
  choice :share_info_entries, :selection => :entriesRead do
    uint32 0
    share_info_0 :default
  end
end

class Share_info_1 < BinData::Record
  endian :little
  uint32 :ref_id_shi1_netname, :initial_value => 1
  uint32 :max_count
  array :ref_id_netname, :type => :uint32, :initial_length => :max_count
  array :shi1_type, :type => :uint32, :initial_length => :max_count
  array :ref_id_remark, :type => :uint32, :initial_length => :max_count
  array :netname, :type => :conformantandVaryingStrings, :initial_length => :max_count
  array :remark, :type => :conformantandVaryingStrings, :initial_length => :max_count
end
 

class Share_info_1_container < BinData::Record
  endian :little
  uint32 :entriesRead, :initial_value => 0
  choice :share_info_entries, :selection => :entriesRead do
    uint32 0
    share_info_1 :default
  end
end

class Share_enum_struct < BinData::Record
  endian :little
  uint32 :level
  uint32 :share_enum_union_tag, :initial_value => :level
  uint32 :ref_id_share_info_container, :initial_value => 1
  choice :share_info_container, :selection => :level do
    share_info_0_container 0
    share_info_1_container 1
  end
end

class NetShareEnumReq < BinData::Record
  default_parameter :serverName => ""
  endian :little
  request :request
  uint32 :ref_id_unc, :value => 1                                       #NDR WLPChar host UNC 
  conformantandVaryingStrings :conformantandVaryingStrings
  share_enum_struct :share_enum_struct
  uint32 :max_buffer, :initial_value => 0xffffffff
  uint32 :ref_id_resume, :initial_value => 1    #unique pointer(can have null)
  uint32 :resume_handle, :initial_value => 0

  def initialize_instance
    super
    conformantandVaryingStrings.str = "\\\\#{get_parameter(:serverName)}\x00".bytes.pack("v*")
    request.pduHead.frag_length = self.num_bytes
    request.pduHead.ptype.value = 0
    request.opnum.value = 15
    share_enum_struct.level = 1
  end
end

class Response < BinData::Record
  endian :little
  pduHead :pduHead
  uint32 :alloc_hint
  uint16 :p_cont_id
  uint8 :cancel_count
  uint8 :reserved


  #string :auth_verifier, :onlyif => lambda { pduHead.auth_length > 0 }, :length => lambda { pduHead.auth_length }
end



class NetShareEnumRes < BinData::Record
  endian :little
  response :response
  share_enum_struct :share_enum_struct
  uint32 :totalEntries
  uint32 :ref_id_resume
  uint32 :resume_handle
  uint32 :windowsError
#uint32 :sth1
#uint32 :sth2
#uint32 :sth3
#response packet
#NET_API_STATUS NetrShareEnum( 
#[in, out] LPSHARE_ENUM_STRUCT InfoStruct, 
#[out] DWORD* TotalEntries,
#[in, out, unique] DWORD* ResumeHandle );

end

#  endian :little
#  uint8  :rpc_vers, :value => 5
#  uint8  :rpc_vers_minor
#  uint8  :ptype					#packet type
#  uint8  :pfc_flags, :initial_value => lambda{ PFC_FIRST_FRAG | PFC_LAST_FRAG}			#flags (see PFC_... )
#  uint32 :drep, :initial_value => 0x10		#NDR data representation format label
#  uint16 :frag_length				#total length of the PDU
#  uint16 :auth_length				#length of auth_value
#  uint32 :call_id, :initial_value => 1		#call identifier for matching rewponse like smb msg ID
#end

#class PSyntaxId < BinData::Record
#  endian :little
#  string :uuid, :length => 16
#  uint16 :if_version_major
#  uint16 :if_version_minor

#  def ndrParse(uuidStr, ver)
#    uuidArr = uuidStr.split("-")
#    uuidArr[0] = uuidArr[0].to_i(16)
#    uuidArr[1] = uuidArr[1].to_i(16)
#    uuidArr[2] = uuidArr[2].to_i(16)
#    uuidArr[3] = uuidArr[3].to_i(16)
#    uuid.value = uuidArr.pack("VvvnH*")
#    verArr = ver.to_s.split(".")
#    if_version_major.value = verArr[0].to_i
#    if_version_minor.value = verArr[1].to_i
#  end
#end

#class PContentElement < BinData::Record
#  endian :little
#  uint16 :p_context_id
#  uint8 :n_transfer_syn, :initial_value => 1
#  uint8 :reserved
#  pSyntaxId :abstract_syntax
#  array :transfer_syntaxes, :type => pSyntaxId, :initial_length => :n_transfer_syn
#end

#class PContentList < BinData::Record
#  endian :little
#  uint8  :n_context_elem, :initial_value => 1
#  uint8 :reserved
#  uint16 :reserved2
#  array :elements, :type => PContentElement, :initial_length => :n_context_elem
#end

#class Bind < BinData::Record
#  endian :little
#  head :head
#  uint16 :max_xmit_frag, :initial_value => 0xffff
#  uint16 :max_recv_frag, :initial_value => 0xffff
#  uint32 :assoc_group_id
#  pContentList :p_cont_elem
#  def cal
#   p self.to_binary_s.bytesize
#  end

#def addpContentList(pList)
# self.p_cont_elem.n_context_elem = pList.length
#  self.p_cont_elem.elements = pList
#end

#end

#PDU Type	Protocol	Type Value
#request		CO/CL		0
#ping		CL		1
#response	CO/CL		2
#fault		CO/CL		3
#working		CL		4
#nocall		CL		5
#reject		CL		6
#ack		CL		7
#cl_cancel	CL		8
#fack		CL		9
#cancel_ack	CL		10
#bind		CO		11
#bind_ack	CO		12
#bind_nak	CO		13
#alter_context	CO		14
#alter_context_resp	CO	15
#shutdown	CO		17
#co_cancel	CO		18
#orphaned	CO		19
